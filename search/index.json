[{"content":"问题 代码 1 2 3 4 5  vector\u0026lt;int\u0026gt; vec; // some code here for (int i = 0; i \u0026lt; vec.size() - 1; i ++ ) { cout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }   原本思路 只打印$vec$的前$|vec| - 1$个元素，就用这个挺好！\n显示出的问题 Segmentation Fault 11/0/11\n解读 1 2  C:/blahblah/blahblahblah.cpp:2022:23: warning: comparison of integer expressions of different signedness: \u0026#39;int\u0026#39; and \u0026#39;std::vector\u0026lt;int\u0026gt;::size_type\u0026#39; {aka \u0026#39;long long unsigned int\u0026#39;} [-Wsign-compare] for (int i = 0; i \u0026lt; vec.size(); i ++ ) {   可以发现如果size是$0$那么就会减出$18446744073709551615$，明显是要报错的。\n","date":"2022-08-11T14:38:00+08:00","permalink":"https://www.pythoner.work/post/unsigned-cannot-sub1/","title":"size_t相当于unsigned long long"},{"content":"目的 求$m ^ k$ $\\bmod$ $p$\n反复平方法 预处理 $O(k)$预处理出来以下的数：\n$m ^ {2 ^ 0}$ $\\bmod$ $p$\n$m ^ {2 ^ 1}$ $\\bmod$ $p$\n$m ^ {2 ^ 2}$ $\\bmod$ $p$\n\u0026hellip;\n$m ^ {2 ^{\\log{k}}}$ $\\bmod$ $p$\n怎么做？直接循环！代码忽略，因为还要优化。\n算答案 举例子，$4 ^{5}$ $\\bmod$ $10$ $ = (4^{2 ^ 2}$ $\\bmod$ $10$ $\\times$ $4 ^{2 ^ 0}$ $\\bmod$ $10)$ $\\bmod$ $10$\n就可以调预处理的数了，\n$4^{2 ^ 2}$ $\\bmod$ $10$ $ = $ $6$\n$4^{2 ^ 0}$ $\\bmod$ $10$ $ = $ $4$\n$(6$ $\\times$ $4)$ $\\bmod$ $10$ $ = $ $4$\n验证一下：\n$4^5$ $\\bmod$ $10$ $=$ $1024$ $\\bmod$ $10$ $=$ $4$\n把$k$转化为二进制并取出对应的数再相乘，$O(k)$。\n把两个步骤合在一起 1 2 3 4 5 6 7 8 9  int qmi(int m, int k, int p) { int t = 1 % p; while (k) { if (k \u0026amp; 1) t = (LL)t * m % p; m = (LL)m * m % p; k \u0026gt;\u0026gt;= 1; } return t; }   关键操作：\n k \u0026amp; 1 $k$ 的末位（二进制）为$0$ LL 乘的过程可能会爆int，使用long long  至此，模板题就可以$\\Large{\\color{green}{AC}}$辣！\n应用题 幂次方 题面 对任意正整数 $N$，计算 $X^N \\bmod 233333$ 的值。\n（输入输出不用管他）\n解法 把$233333$看作$p$，彻头彻尾的一道快速幂题。\nqmi(X, N, 233333)\n越狱 题面 监狱有连续编号为 $1$ 到 $n$ 的 $n$ 个房间，每个房间关押一个犯人。\n有 $m$ 种宗教，每个犯人可能信仰其中一种。\n如果相邻房间的犯人信仰的宗教相同，就可能发生越狱。\n求有多少种状态可能发生越狱，对 $100003$ 取余。\n解法 直接想发生越狱的情况数不好想，那就想不发生越狱，$1$有$n$钟选择，$2$要想不发生越狱需要避开$1$的选择，有$n - 1$钟，后面的每一个人都需要避开前面一人的选择，都是$n - 1$种选择。列算式： $$m (m - 1)^{n-1}$$ 那不越狱的方案数就是： $$m^n - m(m - 1)^{n - 1}$$ 用快速幂解决问题。\n","date":"2022-08-11T11:56:00+08:00","permalink":"https://www.pythoner.work/post/qmi/","title":"快速幂"},{"content":"CSP-J 2021 T1 分糖果\nT2 插入排序\nT3 网络连接\nT4 小熊的果篮\nCSP-J 2020 T1 优秀的拆分\nT2 直播获奖\nT3 表达式\nT4 方格取数\nCSP-J 2019 T1 数字游戏\nT2 公交换乘\nT3 纪念品\nT4 加工领奖\nNOIP2018 普及组 T1 标题统计\nT2 龙虎斗\nT3 摆渡车\nT4 对称二叉树\nNOIP2017 普及组 T1 成绩\nT2 图书管理员\nT3 棋盘\nT4 跳房子\nNOIP2016 普及组 T1 买铅笔\nT2 回文日期\nT3 海港\nT4 魔法阵\n","date":"2022-08-10T17:51:00+08:00","permalink":"https://www.pythoner.work/post/cspj-noip1-problem/","title":"CSP-J/NOIP普及组复赛历年试题汇总"},{"content":"题目大意 求$P_{n}^{m}$的二进制的后面有几个0。\n$1\\le m \\le n \\le 10000$\n解法 二进制可以忽略，完全是出于出题人想搞晕做题人。\n十进制中尾部的0的个数就是因数10的数量，二进制就是2。\n","date":"2022-07-12T13:57:00+08:00","permalink":"https://www.pythoner.work/post/sol-acw3588/","title":"排列与二进制"},{"content":"不放回（无重排列组合） 有序 $$P_n^m$$\n无序 $$C_n^m$$\n放回（可重排列组合） 有序 一个一个取，每步可以有$n$种选择，乘法原理： $$n \\times n \\times n \\times\u0026hellip;\\times n\\ = n^m$$\n无序 可重组合，可记作： $\\bar{C}_n^m$（c bar n m)， $H_n^m$。\n重点：隔板法\n从$n$元集中可重复的选取$m$个元素，则方程$x_1 + x_2 + x_3 + \u0026hellip; + x_n = m$的非负整数解的个数就是可以选的方式的总个数。那么我们可以把这个问题看成在$m$个元素中插入$n-1$个分隔符，每段中是一种元素，就是在$n+m-1$个位置中选取$n-1$个放分隔符，也是$n+m-1$个位置中选取$m$个不放分隔符，就可以用无重组合的方式表示可重组合： $$C_{n+m-1}^{m}$$\n无序，每种至少选一个 可重组合的变形，仍使用隔板法。\n这次每种至少选一个的使得两个隔板不能放在一起，位置数减小到了$m - 1$，所以答案就是： $$C_{m-1}^{n-1}$$\n","date":"2022-07-10T11:52:00+08:00","permalink":"https://www.pythoner.work/post/counting/","title":"从n个球中取m个"},{"content":"比赛简介  题数：4道 时间：3个小时 总分：400分 难度：2道J2，2道S2 晋级标准:前100名  开始考试 先来讲题。\nA题签到题忽略…… CD题目前没能力解决，也忽略。\nB：Mila的木棍 题面 $\\text{Mila}$ 找到了 $n$ 根木棍，她将这 $n$ 根木棍排成一行形成一个序列 $a$，但是她发现此时的序列可能是不优美的。\n假如木棍的长度从左到右形成一个不下降序列，那么 $\\text{Mila}$ 认为这些木棍才是优美的。因此，$\\text{Mila}$ 学习了一种可以削减木棍长度的魔法：对一个区间 $[l,r]$ 使用一次魔法，可以将这个区间内所有木棍的长度减 $1$。\n不下降序列：对于所有 $1\\leq j \u0026lt; i \\leq n$，满足 $a[j] \\leq a[i]$。例如序列 $3,3,4,5$ 就是不下降序列。\n现在 $\\text{Mila}$ 想要知道：至少需要使用多少次魔法才可以将这些木棍变得优美？\n输入格式 第一行一个整数 $n$，表示木棍的数量。\n第二行 $n$ 个以空格隔开的整数，表示这个序列，第 $i$ 根木棍的长度为 $a_i$。\n输出格式 输出共一行一个整数，表示答案。\n数据范围 对于 $20%$ 的数据，满足 $n,a_i\\leq 10$。\n对于 $40%$ 的数据，满足 $n\\leq 10^3$。\n对于另外 $20%$ 的数据，保证 $a$ 是一个不递增序列。\n对于 $100%$ 的数据，满足 $1\\leq n\\leq 10^6,1\\leq a_i\\leq 10^9$。\n样例输入 1 2  3 1 3 2   样例输出 1  1   满分解 对于一个$i$，如果$a_i \\gt a_{i + 1}$，那么为了形成不下降序列，至少有$a_i - a_{i + 1}$次削减的区间的右端点需位于$i$。\n所以操作数至少为$\\sum_{i=1}^{n - 1} max(a_i - a_{i + 1}, 0)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long LL; int main() { freopen(\u0026#34;stick.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;stick.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); int n; cin \u0026gt;\u0026gt; n; LL prev, ans; cin \u0026gt;\u0026gt; prev; n -- ; while (n -- ) { int a; cin \u0026gt;\u0026gt; a; if (prev \u0026gt; a) { ans += prev - a; } prev = a; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }   总结 要用草稿纸 不用草稿纸基本只能做签到题，况且这场比赛难度确实不低。\n","date":"2022-05-03T17:17:51+08:00","image":"https://www.pythoner.work/post/jisuanke-dao-2022-a1/dao-2022_hub421deb031285c54d2f390bf85a1401b_22036_120x120_fill_box_smart1_3.png","permalink":"https://www.pythoner.work/post/jisuanke-dao-2022-a1/","title":"2022计蒜之道初赛（第一场）"},{"content":"题目 题目链接：景区三角形\n解法 暴力解 直接找出三个点，进行check()，非常简单的思路。\n满分解 很明显，这是一个无向图，看数据范围可以看出应该用邻接表。\n暴力解的缺点在于可能挑出三个毫无关联的点，那就让每个点拥有1个$fa$，有了它的存在， 我们就得找这个图的生成树，因为起码得有个点是根才有$fa$的概念。\n假设遍历到的点是$cur$，找到相邻点$v$，那么我们只用看$fa$和$v$是否相邻了，变得非常简单， 复杂度降低了很多。\n最终，再来谈论一下实现，在判断是否相邻时，使用二分查找，进一步优化。\n放代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; const int N = 1e5 + 10; int n, m; bool st[N]; int a, b, c; vector\u0026lt;int\u0026gt; G[N]; struct Node { int x, fa; }; int main() { freopen(\u0026#34;triangle.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;triangle.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i ++ ) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } for (int i = 1; i \u0026lt;= n; i ++ ) { sort(G[i].begin(), G[i].end()); } // bfs  queue\u0026lt;Node\u0026gt; q; q.push(Node{1, -1}); st[1] = 1; while (!q.empty()) { Node cur = q.front(); q.pop(); bool flag = false; for (int i = 0; i \u0026lt; G[cur.x].size(); i ++ ) { int v = G[cur.x][i]; if (cur.fa != -1 \u0026amp;\u0026amp; st[v] \u0026amp;\u0026amp; v != cur.fa \u0026amp;\u0026amp; binary_search(G[v].begin(), G[v].end(), cur.fa)) { a = cur.fa; b = cur.x; c = v; if (a \u0026gt; b) swap(a, b); if (b \u0026gt; c) swap(b, c); if (a \u0026gt; b) swap(a, b); flag = true; break; } if (!st[v]) { st[v] = true; q.push(Node{v, cur.x}); } } if (flag) break; } printf(\u0026#34;%d %d %d \\n\u0026#34;, a, b, c); return 0; }   拓展：基本不使用STL完成这道题 手写邻接表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int h[N]; // 链表头 int e[M]; // 通往哪个点 int ne[M]; // 链表中下一个 int w[M]; // 边权 int idx; // 记录到第几条边  // 无权加边（有向） void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 有权加边（有向） void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; }   手写队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  int q[N], hh, tt; // q.empty() hh == tt // q.push(x); q[++ tt] = x; // q.front() q[hh + 1] // q.pop(); hh ++ ; // bfs模板 q[++ tt] = x; st[x] = true; while (hh != tt) { hh ++ ; if (check(q[hh])) { q[++ tt] = get(q[hh]); } }   完整代码 注：抛弃了二分，否则太复杂了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; const int N = 1e5 + 10; int n, m; bool st[N]; int a, b, c; int h[N], e[N], ne[N], idx; int q[N], fa[N], hh, tt; void add(int u, int v) { e[idx] = v, ne[idx] = h[u], h[u] = idx ++ ; } bool find(int u, int v) { for (int i = h[u]; i != -1; i = ne[i]) { if (e[i] == v) return true; } return false; } void swap(int \u0026amp;x, int \u0026amp;y) { int z = x; x = y; y = z; } int main() { memset(h, -1, sizeof h); freopen(\u0026#34;triangle.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;triangle.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i ++ ) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u, v); add(v, u); } q[++ tt] = 1; fa[tt] = -1; st[1] = 1; while (hh != tt) { hh ++ ; bool flag = false; for (int i = h[q[hh]]; i != -1; i = ne[i]) { int v = e[i]; if (fa[hh] != -1 \u0026amp;\u0026amp; st[v] \u0026amp;\u0026amp; v != fa[hh] \u0026amp;\u0026amp; find(fa[hh], v)) { a = fa[hh]; b = q[hh]; c = v; if (a \u0026gt; b) swap(a, b); if (b \u0026gt; c) swap(b, c); if (a \u0026gt; b) swap(a, b); flag = true; break; } if (!st[v]) { st[v] = true; q[++ tt] = v; fa[tt] = q[hh]; } } if (flag) break; } printf(\u0026#34;%d %d %d \\n\u0026#34;, a, b, c); return 0; }   ","date":"2022-05-01T21:07:00+08:00","permalink":"https://www.pythoner.work/post/sol-jisuanke-t3633/","title":"景区三角形"},{"content":"考试简介  题数：5道 时间：2个小时 总分：500分 难度：低于CSP-J  题目 ABC题没难度，忽略。\nD：购机攻略 链接：购机攻略\n思路 直接模拟，由于sort()只能排序单个内容，不能排序散的内容，用struct。\n易错点 sort()只能排序单个内容，不能排序散的内容，用struct。\nE：暑假作业 链接：暑假作业\n思路 和二分求一个数的立方根这类的题相似，就用二分。\n可以知道答案最少是1，至多是最大的元素，在这两个值中间二分。\n易错点 容易想不到要二分……\n总结 不能不拿部分分 DE两题是放弃了，所以得了300分，如果拿部分分就是360分，多了足足60分！！！\n要有思考，不能光是暴力 很多算法都是先想暴力做法及其缺点再进行优化，我们也要学习。\n不能想问题想的过于死板 D题根本就没想到sort()不能排散东西。\n","date":"2022-04-23T18:00:00+08:00","permalink":"https://www.pythoner.work/post/xiaotuling-202204/","title":"有道小图灵3级（2022年4月）"},{"content":"比赛简介  题数：4道 时间：2个小时 总分：400分 难度：和CSP-J2难度相当  开始考试 先来讲题。\nA题签到题忽略……\nB：完美数列 题目链接：完美数列\n暴力解法 直接找最大值砍下去。\n60分解法（实际90分） 使用priority_queue来找最大值，一层一层砍。\n满分解 二分答案法，非常简洁！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long LL; const int N = 1e6 + 10; int n, p; LL w, s[N]; int a[N]; bool check(int x) { int idx = upper_bound(a, a + n, x) - a; LL len = n - idx; LL tmp = s[idx] - len * x; return tmp \u0026lt;= w / p; } int main() { freopen(\u0026#34;money.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;money.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p \u0026gt;\u0026gt; w; for (int i = 0; i \u0026lt; n; i ++ ) cin \u0026gt;\u0026gt; a[i]; sort(a, a + n); for (int i = n - 1; i \u0026gt;= 0; i -- ) { s[i] = s[i + 1] + a[i]; } int l = 0, r = 1e9 + 10; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) { r = mid; } else { l = mid + 1; } } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; return 0; }   C：传递 题目链接：传递\n40分 冒泡排序，边排边计算代价，非常暴力……\n满分解 这是带权逆序对问题。\n所以通过归并求逆序对，从$p_2$移到$p_1$需要耗费代价\n$((p_2 + mid)^2 + (p_2 + mid - 1)^2 + \u0026hellip; + (p_2 + p_1)^2) + (2 * w[mid] * w[p_2] + 2 * w[mid - 1] * w[p_2] + \u0026hellip; + 2 * w[p_1] * w[p_2]) + (mid - p_1 + 1) * w[p_2]$\n然后，维护$w[i]$和$w[i] ^ 2$的后缀和就OK了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long LL; const int N = 5e5 + 10, P = 1e9 + 7; int n; int w[N], p[N]; int a[N], b[N]; LL sum1[N], sum2[N]; LL ans; void merge(int l, int r) { int mid = (l + r) \u0026gt;\u0026gt; 1; int p1 = l, p2 = mid + 1; int m = l; sum1[mid + 1] = sum2[mid + 1] = 0; for (int i = mid; i \u0026gt;= l; i -- ) { sum1[i] = (sum1[i + 1] + w[i]) % P; sum2[i] = (sum2[i + 1] + ((LL)w[i] * w[i]) % P) % P; } while (p1 \u0026lt;= mid \u0026amp;\u0026amp; p2 \u0026lt;= r) { if (p[p1] \u0026lt;= p[p2]) { b[m] = w[p1]; a[m ++ ] = p[p1 ++ ]; } else { ans = (ans + sum2[p1]) % P; ans = (ans + 2 * sum1[p1] * w[p2] % P) % P; ans = (ans + (LL)(mid - p1 + 1) * w[p2] * w[p2] % P) % P; b[m] = w[p2]; a[m ++ ] = p[p2 ++ ]; } } while (p1 \u0026lt;= mid) { b[m] = w[p1]; a[m ++ ] = p[p1 ++ ]; } while (p2 \u0026lt;= r) { b[m] = w[p2]; a[m ++ ] = p[p2 ++ ]; } for (int i = l; i \u0026lt;= r; i ++ ) { p[i] = a[i]; w[i] = b[i]; } } void msort(int l, int r) { if (l == r) { return; } int mid = (l + r) \u0026gt;\u0026gt; 1; msort(l, mid); msort(mid + 1, r); merge(l, r); } int main() { freopen(\u0026#34;transfer.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;transfer.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i ++ ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i]); } for (int i = 1; i \u0026lt;= n; i ++ ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;p[i]); } msort(1, n); printf(\u0026#34;%lld\u0026#34;, ans); return 0; }   D：景区三角形 题目链接：景区三角形\n暴力解法 就$O(n^3)$找三个点，做个check()，就结束了，不再赘述。\n满分解 通过bfs找三角形，一个点设一个$fa$，根（1）等于$-1$。\n有点像找生成树。\n找到一个点$v$，判断$fa$，$cur$，$v$是否构成三角形，如果是，排序放进答案里输出，如果$v$没遍历过，遍历$v$。\n这道题我写了更详细的题解（代码也包装进去了，这里不放了哈）： 题解-景区三角形\n总结 不能放弃，记得调试 C题本来能40分的，但是没调试，放弃了，代码都没存档……\n注意亿些关于输入输出的低级问题 赛后调试一道题时发现有问题，结果，没想到，freopen忘记注释了……\n要用草稿纸 不用草稿纸基本只能做签到题，有些考试中的B题可能也不难，也能做出来。 关于C题的推导其实很长这件事……\n想算法时的方法很重要 签到题如果复杂度不超标就行，这回也就简简单单一个快速幂。\n其他题可以由复杂度推出算法，或是从暴力法开始优化，都可以。\n","date":"2022-04-23T15:00:00+08:00","permalink":"https://www.pythoner.work/post/jisuanke-202204/","title":"计蒜客4月月赛（普及组）"},{"content":"功能 1 2 3 4  add(8); add(9); find(10); // false find(8); // true   实现 首先，写一个散列函数。\n1 2 3  int get(int x) { return (x % N + N) % N; // 解决负数问题 }   接着，就出现了问题，散列值可能发生碰撞，如何解决呢？\n拉链法 每个散列值存一个链表（结构就很像邻接表了）。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  #include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100003; int h[N], e[N], ne[N], idx; void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); memset(h, -1, sizeof h); while (n -- ) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); if (*op == \u0026#39;I\u0026#39;) { insert(x); } else { if (find(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; }   开放寻址法 通过让N增大减少碰撞。 并在每次碰撞发生时向后找空位（这是放的时候）。 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 200003, null = 0x3f3f3f3f; int h[N]; int find(int x) { int t = (x % N + N) % N; while (h[t] != null \u0026amp;\u0026amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } int main() { memset(h, 0x3f, sizeof h); int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while (n -- ) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); if (*op == \u0026#39;I\u0026#39;) { h[find(x)] = x; } else { if (h[find(x)] == null) puts(\u0026#34;No\u0026#34;); else puts(\u0026#34;Yes\u0026#34;); } } return 0; }   ","date":"2022-04-21T21:24:00+08:00","permalink":"https://www.pythoner.work/post/hashtable/","title":"哈希表"},{"content":"循环队列 功能 节省空间，比如说：\n操作：\n1  push(1); pop(); push(2); pop();   效果： hh以前的空间不能用了。\n用循环队列可以把队列拉成数组的长度，而普通队列不一定。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  #include \u0026lt;iostream\u0026gt; using namespace std; // 队列长度，可以自己修改。 const int N = 10; // 队列 struct Queue { int q[N]; int hh = 1, tt = 0; void push(int x) { q[( ++ tt) % N] = x; if (hh / N \u0026amp;\u0026amp; tt / N) { hh -= (int)min(hh / N, tt / N) * N; tt -= (int)min(hh / N, tt / N) * N; } } void pop() { hh ++ ; } int front() { return q[hh % N]; } int back() { return q[tt % N]; } bool empty() { return hh \u0026gt; tt; } int size() { return tt - hh + 1; } }; // 调试 int main() { Queue q; q.push(1); q.pop(); q.push(1); q.push(2); cout \u0026lt;\u0026lt; (q.empty() ? \u0026#39;Y\u0026#39; : \u0026#39;N\u0026#39;) \u0026lt;\u0026lt; endl; q.push(3); q.pop(); q.pop(); q.pop(); q.push(1); q.push(2); q.push(3); cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; q.back() \u0026lt;\u0026lt; endl; q.push(4); q.push(5); cout \u0026lt;\u0026lt; q.size(); q.push(6); q.pop(); q.pop(); q.pop(); q.pop(); q.pop(); q.pop(); return 0; }   版权问题 没有问题，背着抱着都行。\n评论区问题 评论区不能抱走， sofa你是背不动滴，给我一句留言我就让你抱走。\n","date":"2022-04-19T15:25:00+08:00","permalink":"https://www.pythoner.work/post/circular-linked-list/","title":"循环队列"}]
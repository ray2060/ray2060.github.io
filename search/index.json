[{"content":"Day -1 摆烂。\n忘记查哪个考场了。\nDay 0 7:30 乘坐出租车（拼车？）前往rdfz。\n8:15 进考场，听不明白监考老师在说什么。\n花了3分钟才把回收系统的地址抄下来，然后发现坐错了。\n8:26 发了试题，看题……\n我喜欢把四道题分别叫成 ABCD，结果发现第一题叫 Apple，第四题叫 Bus……\n9:12 提交 AB 两题。\n觉得 200 分起步。\n11:12 搞不明白 C，拿点部分分走人。\n11:47 交了 D，觉得在 C 上浪费时间太多了，不然可以写正解 dij 的。\n12:00 离场，前往麦吃午饭。\n排大队啊！离谱！\n最后总算吃上了。\n14:00 进考场。rdf风景不错。\n不让带食品和水。\n15:15 开始摆烂……\n太难了吧！\n至少能保证把 A 过掉。\n18:30 考完了，啃带来的巧克力。\n18:40 rdfz夜景真的很好看，可惜没带手机。\n出了考场才知道前年CSP是在这考的。\nJ 组估分 $130$。\n未完待续 ","date":"2023-10-21T21:25:00+08:00","permalink":"https://www.pythoner.work/post/tn004-csp-2023-second/","title":"CSP 2023 游记"},{"content":"Day -1 确定考场：北京市第八十中学\n啊这……去过不知道多少遍了……\nDay 0 9:30 发卷。\n钉在一起了？这……不太好翻吧？\n11:10 做完了，觉得没什么好检查的了，直接涂答题卡。\n迷惑身边的学长怎么涂了半小时。\n11:30 考完了，经典收卷不能离开座位。\n14:30 时间挺紧，继续考S组。\n15:10 已经把会做的题都做完了，决定开始涂答题卡。\n15:45 欣赏风景……^_^\n16:30 交卷，轻松。\n比去年只打J组还轻松。\n17:30 J组估分 $69$，比去年低了 $10$ 分！\n不应该啊，今年题比去年简单 $10$ 倍。\nDay 1 周日，原神？启动！。\nS组估分 $47.5$，正常，毕竟我也没认真答。\nDay ? 最后成绩：\n   CSP-J CSP-S     66 52.5   晋级 晋级   ?等奖 ?等奖    ","date":"2023-09-17T09:14:00+08:00","permalink":"https://www.pythoner.work/post/tn003-csp-2023-first/","title":"CSP 2023 游记"},{"content":"爆掉出现的问题 此处使用爆int举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;iostream\u0026gt; using namespace std; bool check(int x) { return x \u0026gt; 1919810; } int main() { int l = 114514, r = 2.14748e9; while ((r - l) \u0026gt; 1) { // 1.  int mid = (l + r) / 2; // 2.  int mid = l + (r - l) / 2; if (check(mid)) { r = mid; } else { l = mid + 1; } } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; return 0; }   结果是：\n使用1号代码输出-1073686390，使用2号代码输出1919810。\n为什么它等于mid $L+\\frac{R-L}{2} = \\frac{2L + R - L}{2} = \\frac{L + R}{2}$\n就是l和r的平均值mid。\n为什么不会爆 首先，一般的二分答案都是二分正数（不是的话，答案范围一般不大，如浮点二分三次方根），那r - l就不会爆。\nr - l不爆，(r - l) / 2也不会爆。\n至于l + (r - l) / 2，很明显，这个值一定在l和r之间，既然l和r不爆，那这个就不可能爆。\n总结 当然，除非真的要爆long long了才会用这招，不然写错了可就爆0了。\n注：写二分也要注意边界条件哈，听说只有 $10%$ 的程序员能写对二分hhh。\n附：整型浮点型爆炸极限    类型名 二分爆炸极限 EPS建议值     int $l = 0, r = 10^{9}$ ???   long long $l = 0, r = 4.6 \\times 10^{18}$ ???   double ??? $10^{-8}$ 一般就用 $10^{-5}$（可存15位十进制）   long double ??? $10^{-26}$ 一般不用太精确，所以 $10^{-15}$ 就差不多（可存33位十进制）    ","date":"2022-10-23T14:07:00+08:00","permalink":"https://www.pythoner.work/post/exp002-bs-ll-overflow/","title":"二分爆long long解决方法"},{"content":"Day -2 今天做了个模拟，成绩65，一般般。最主要的是保持一个好状态准备迎接J1。\nDay -1 小图灵集训队集训日。今天终于能从J1的思维中跳出来放松一下了！\nDay 0 7:30 起床了！洗把脸清醒一下。\n8:10 坐上出租车冲向考场！路上复习一下排序的稳定性。\n8:45 到达考场所在大厦的楼底下。\n验证身份后拿起袋子爬楼，要爬7楼。\n走进考场，好紧张好紧张。没想到能遇到同学校的学长，心放下来了一半。\n9:30 发卷。\n拿到卷子，先浏览一遍，可以看出没有组合数学，位运算放到了阅读程序第一题，阅读第二三题看起来很难，要多分配时间，补全程序很简单，枚举和floodfill。\n11:00 做完了，还要检查。\n居然出租车上复习都能压中题，欧皇附身了！\n11:30 下楼啦，心全放下来了。\n19:00 直播时间到！\n没想到考后7小时就出估分了，77不是太好。能现场听题解，所有不懂的地方全懂了。\nDay 1 周一，上学。\n上课就只有两个字，好困！\nDay 3 估分更正，79。\n这道题到底说的是强连通还是弱联通？！\n9.考虑由 $N$ 个顶点构成的有向连通图，采用邻接矩阵的数据结构表示时，该矩阵中至少存在（ ）个非零元素。\nA $N - 1$\nB $N$\nC $N + 1$\nD $N^2$\nDay 9 出成绩啦，77又变回去了哈哈哈。\n晋级，是肯定的，毕竟我在北京。\n可以冲J2啦。\n","date":"2022-09-18T15:00:00+08:00","permalink":"https://www.pythoner.work/post/tn001-csp-2022-first/","title":"CSP-J1 2022 参赛经历"},{"content":"问题 代码 1 2 3 4 5  vector\u0026lt;int\u0026gt; vec; // some code here for (int i = 0; i \u0026lt; vec.size() - 1; i ++ ) { cout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }   原本思路 只打印$vec$的前$|vec| - 1$个元素，就用这个挺好！\n显示出的问题 Segmentation Fault 11/0/11\n解读 1 2  C:/blahblah/blahblahblah.cpp:2022:23: warning: comparison of integer expressions of different signedness: \u0026#39;int\u0026#39; and \u0026#39;std::vector\u0026lt;int\u0026gt;::size_type\u0026#39; {aka \u0026#39;long long unsigned int\u0026#39;} [-Wsign-compare] for (int i = 0; i \u0026lt; vec.size(); i ++ ) {   可以发现如果size是$0$那么就会减出$18446744073709551615$，明显是要报错的。\n","date":"2022-08-11T14:38:00+08:00","permalink":"https://www.pythoner.work/post/exp001-unsigned-no-sub1/","title":"size_t相当于unsigned long long"},{"content":"目的 求$m ^ k$ $\\bmod$ $p$\n反复平方法 预处理 $O(k)$预处理出来以下的数：\n$m ^ {2 ^ 0}$ $\\bmod$ $p$\n$m ^ {2 ^ 1}$ $\\bmod$ $p$\n$m ^ {2 ^ 2}$ $\\bmod$ $p$\n\u0026hellip;\n$m ^ {2 ^{\\log{k}}}$ $\\bmod$ $p$\n怎么做？直接循环！代码忽略，因为还要优化。\n算答案 举例子，$4 ^{5}$ $\\bmod$ $10$ $ = (4^{2 ^ 2}$ $\\bmod$ $10$ $\\times$ $4 ^{2 ^ 0}$ $\\bmod$ $10)$ $\\bmod$ $10$\n就可以调预处理的数了，\n$4^{2 ^ 2}$ $\\bmod$ $10$ $ = $ $6$\n$4^{2 ^ 0}$ $\\bmod$ $10$ $ = $ $4$\n$(6$ $\\times$ $4)$ $\\bmod$ $10$ $ = $ $4$\n验证一下：\n$4^5$ $\\bmod$ $10$ $=$ $1024$ $\\bmod$ $10$ $=$ $4$\n把$k$转化为二进制并取出对应的数再相乘，$O(k)$。\n把两个步骤合在一起 1 2 3 4 5 6 7 8 9  int qmi(int m, int k, int p) { int t = 1 % p; while (k) { if (k \u0026amp; 1) t = (LL)t * m % p; m = (LL)m * m % p; k \u0026gt;\u0026gt;= 1; } return t; }   关键操作：\n k \u0026amp; 1 $k$ 的末位（二进制）为$0$ LL 乘的过程可能会爆int，使用long long  至此，模板题就可以$\\Large{\\color{green}{AC}}$辣！\n应用题 幂次方 题面 对任意正整数 $N$，计算 $X^N \\bmod 233333$ 的值。\n（输入输出不用管他）\n解法 把$233333$看作$p$，彻头彻尾的一道快速幂题。\nqmi(X, N, 233333)\n越狱 题面 监狱有连续编号为 $1$ 到 $n$ 的 $n$ 个房间，每个房间关押一个犯人。\n有 $m$ 种宗教，每个犯人可能信仰其中一种。\n如果相邻房间的犯人信仰的宗教相同，就可能发生越狱。\n求有多少种状态可能发生越狱，对 $100003$ 取余。\n解法 直接想发生越狱的情况数不好想，那就想不发生越狱，$1$有$n$钟选择，$2$要想不发生越狱需要避开$1$的选择，有$n - 1$钟，后面的每一个人都需要避开前面一人的选择，都是$n - 1$种选择。列算式： $$m (m - 1)^{n-1}$$ 那不越狱的方案数就是： $$m^n - m(m - 1)^{n - 1}$$ 用快速幂解决问题。\n","date":"2022-08-11T11:56:00+08:00","permalink":"https://www.pythoner.work/post/algo002-qmi/","title":"快速幂"},{"content":"不放回（无重排列组合） 有序 $$P_n^m$$\n无序 $$C_n^m$$\n放回（可重排列组合） 有序 一个一个取，每步可以有$n$种选择，乘法原理： $$n \\times n \\times n \\times\u0026hellip;\\times n\\ = n^m$$\n无序 可重组合，可记作： $\\bar{C}_n^m$（c bar n m)， $H_n^m$。\n重点：隔板法\n从$n$元集中可重复的选取$m$个元素，则方程$x_1 + x_2 + x_3 + \u0026hellip; + x_n = m$的非负整数解的个数就是可以选的方式的总个数。那么我们可以把这个问题看成在$m$个元素中插入$n-1$个分隔符，每段中是一种元素，就是在$n+m-1$个位置中选取$n-1$个放分隔符，也是$n+m-1$个位置中选取$m$个不放分隔符，就可以用无重组合的方式表示可重组合： $$C_{n+m-1}^{m}$$\n无序，每种至少选一个 可重组合的变形，仍使用隔板法。\n这次每种至少选一个的使得两个隔板不能放在一起，位置数减小到了$m - 1$，所以答案就是： $$C_{m-1}^{n-1}$$\n","date":"2022-07-10T11:52:00+08:00","permalink":"https://www.pythoner.work/post/comb001-counting/","title":"从n个球中取m个"},{"content":"题目 题目链接：景区三角形\n解法 暴力解 直接找出三个点，进行check()，非常简单的思路。\n满分解 很明显，这是一个无向图，看数据范围可以看出应该用邻接表。\n暴力解的缺点在于可能挑出三个毫无关联的点，那就让每个点拥有1个$fa$，有了它的存在， 我们就得找这个图的生成树，因为起码得有个点是根才有$fa$的概念。\n假设遍历到的点是$cur$，找到相邻点$v$，那么我们只用看$fa$和$v$是否相邻了，变得非常简单， 复杂度降低了很多。\n最终，再来谈论一下实现，在判断是否相邻时，使用二分查找，进一步优化。\n放代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; const int N = 1e5 + 10; int n, m; bool st[N]; int a, b, c; vector\u0026lt;int\u0026gt; G[N]; struct Node { int x, fa; }; int main() { freopen(\u0026#34;triangle.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;triangle.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i ++ ) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } for (int i = 1; i \u0026lt;= n; i ++ ) { sort(G[i].begin(), G[i].end()); } // bfs  queue\u0026lt;Node\u0026gt; q; q.push(Node{1, -1}); st[1] = 1; while (!q.empty()) { Node cur = q.front(); q.pop(); bool flag = false; for (int i = 0; i \u0026lt; G[cur.x].size(); i ++ ) { int v = G[cur.x][i]; if (cur.fa != -1 \u0026amp;\u0026amp; st[v] \u0026amp;\u0026amp; v != cur.fa \u0026amp;\u0026amp; binary_search(G[v].begin(), G[v].end(), cur.fa)) { a = cur.fa; b = cur.x; c = v; if (a \u0026gt; b) swap(a, b); if (b \u0026gt; c) swap(b, c); if (a \u0026gt; b) swap(a, b); flag = true; break; } if (!st[v]) { st[v] = true; q.push(Node{v, cur.x}); } } if (flag) break; } printf(\u0026#34;%d %d %d \\n\u0026#34;, a, b, c); return 0; }   拓展：基本不使用STL完成这道题 链式前向星 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int h[N]; // 链表头 int e[M]; // 通往哪个点 int ne[M]; // 链表中下一个 int w[M]; // 边权 int idx; // 记录到第几条边  // 无权加边（有向） void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 有权加边（有向） void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; }   手写队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  int q[N], hh, tt; // q.empty() hh == tt // q.push(x); q[++ tt] = x; // q.front() q[hh + 1] // q.pop(); hh ++ ; // bfs模板 q[++ tt] = x; st[x] = true; while (hh != tt) { hh ++ ; if (check(q[hh])) { q[++ tt] = get(q[hh]); } }   完整代码 注：抛弃了二分，否则太复杂了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; const int N = 1e5 + 10; int n, m; bool st[N]; int a, b, c; int h[N], e[N], ne[N], idx; int q[N], fa[N], hh, tt; void add(int u, int v) { e[idx] = v, ne[idx] = h[u], h[u] = idx ++ ; } bool find(int u, int v) { for (int i = h[u]; i != -1; i = ne[i]) { if (e[i] == v) return true; } return false; } void swap(int \u0026amp;x, int \u0026amp;y) { int z = x; x = y; y = z; } int main() { memset(h, -1, sizeof h); freopen(\u0026#34;triangle.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;triangle.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i ++ ) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u, v); add(v, u); } q[++ tt] = 1; fa[tt] = -1; st[1] = 1; while (hh != tt) { hh ++ ; bool flag = false; for (int i = h[q[hh]]; i != -1; i = ne[i]) { int v = e[i]; if (fa[hh] != -1 \u0026amp;\u0026amp; st[v] \u0026amp;\u0026amp; v != fa[hh] \u0026amp;\u0026amp; find(fa[hh], v)) { a = fa[hh]; b = q[hh]; c = v; if (a \u0026gt; b) swap(a, b); if (b \u0026gt; c) swap(b, c); if (a \u0026gt; b) swap(a, b); flag = true; break; } if (!st[v]) { st[v] = true; q[++ tt] = v; fa[tt] = q[hh]; } } if (flag) break; } printf(\u0026#34;%d %d %d \\n\u0026#34;, a, b, c); return 0; }    UPD:2023-10-21\n ","date":"2022-05-01T21:07:00+08:00","permalink":"https://www.pythoner.work/post/sol002-jisuanke-t3633/","title":"景区三角形"},{"content":"比赛简介  题数：4道 时间：2个小时 总分：400分 难度：和CSP-J2难度相当  开始考试 先来讲题。\nA题签到题忽略……\nB：完美数列 题目链接：完美数列\n暴力解法 直接找最大值砍下去。\n60分解法（实际90分） 使用priority_queue来找最大值，一层一层砍。\n正解 二分答案法，非常简洁！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long LL; const int N = 1e6 + 10; int n, p; LL w, s[N]; int a[N]; bool check(int x) { int idx = upper_bound(a, a + n, x) - a; LL len = n - idx; LL tmp = s[idx] - len * x; return tmp \u0026lt;= w / p; } int main() { freopen(\u0026#34;money.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;money.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p \u0026gt;\u0026gt; w; for (int i = 0; i \u0026lt; n; i ++ ) cin \u0026gt;\u0026gt; a[i]; sort(a, a + n); for (int i = n - 1; i \u0026gt;= 0; i -- ) { s[i] = s[i + 1] + a[i]; } int l = 0, r = 1e9 + 10; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) { r = mid; } else { l = mid + 1; } } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; return 0; }   C：传递 题目链接：传递\n40分 冒泡排序，边排边计算代价，非常暴力……\n正解 这是带权逆序对问题。\n所以通过归并求逆序对，从$p_2$移到$p_1$需要耗费代价\n$((p_2 + mid)^2 + (p_2 + mid - 1)^2 + \u0026hellip; + (p_2 + p_1)^2) + (2 * w[mid] * w[p_2] + 2 * w[mid - 1] * w[p_2] + \u0026hellip; + 2 * w[p_1] * w[p_2]) + (mid - p_1 + 1) * w[p_2]$\n然后，维护$w[i]$和$w[i] ^ 2$的后缀和就OK了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long LL; const int N = 5e5 + 10, P = 1e9 + 7; int n; int w[N], p[N]; int a[N], b[N]; LL sum1[N], sum2[N]; LL ans; void merge(int l, int r) { int mid = (l + r) \u0026gt;\u0026gt; 1; int p1 = l, p2 = mid + 1; int m = l; sum1[mid + 1] = sum2[mid + 1] = 0; for (int i = mid; i \u0026gt;= l; i -- ) { sum1[i] = (sum1[i + 1] + w[i]) % P; sum2[i] = (sum2[i + 1] + ((LL)w[i] * w[i]) % P) % P; } while (p1 \u0026lt;= mid \u0026amp;\u0026amp; p2 \u0026lt;= r) { if (p[p1] \u0026lt;= p[p2]) { b[m] = w[p1]; a[m ++ ] = p[p1 ++ ]; } else { ans = (ans + sum2[p1]) % P; ans = (ans + 2 * sum1[p1] * w[p2] % P) % P; ans = (ans + (LL)(mid - p1 + 1) * w[p2] * w[p2] % P) % P; b[m] = w[p2]; a[m ++ ] = p[p2 ++ ]; } } while (p1 \u0026lt;= mid) { b[m] = w[p1]; a[m ++ ] = p[p1 ++ ]; } while (p2 \u0026lt;= r) { b[m] = w[p2]; a[m ++ ] = p[p2 ++ ]; } for (int i = l; i \u0026lt;= r; i ++ ) { p[i] = a[i]; w[i] = b[i]; } } void msort(int l, int r) { if (l == r) { return; } int mid = (l + r) \u0026gt;\u0026gt; 1; msort(l, mid); msort(mid + 1, r); merge(l, r); } int main() { freopen(\u0026#34;transfer.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;transfer.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i ++ ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i]); } for (int i = 1; i \u0026lt;= n; i ++ ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;p[i]); } msort(1, n); printf(\u0026#34;%lld\u0026#34;, ans); return 0; }   D：景区三角形 题目链接：景区三角形\n暴力解法 就$O(n^3)$找三个点，做个check()，就结束了，不再赘述。\n正解 通过bfs找三角形，一个点设一个$fa$，根（1）等于$-1$。\n有点像找生成树。\n找到一个点$v$，判断$fa$，$cur$，$v$是否构成三角形，如果是，排序放进答案里输出，如果$v$没遍历过，遍历$v$。\n这道题我写了更详细的题解： 题解-景区三角形\n总结 不能放弃，记得调试 C题本来能40分的，但是没调试，放弃了，代码都没存档……\n注意亿些关于输入输出的低级问题 赛后调试一道题时发现有问题，结果，没想到，freopen忘记注释了……\n要用草稿纸 不用草稿纸基本只能做签到题，有些考试中的B题可能也不难，也能做出来。 关于C题的推导其实很长这件事……\n想算法时的方法很重要 签到题如果复杂度不超标就行，这回也就简简单单一个快速幂。\n其他题可以由复杂度推出算法，或是从暴力法开始优化，都可以。\n UPD:2023/10/21\n ","date":"2022-04-23T15:00:00+08:00","permalink":"https://www.pythoner.work/post/sol001-jisuanke-202204/","title":"计蒜客4月月赛（普及组）"},{"content":"功能 1 2 3 4  add(8); add(9); find(10); // false find(8); // true   实现 首先，写一个散列函数。\n1 2 3  int get(int x) { return (x % N + N) % N; // 解决负数问题 }   接着，就出现了问题，散列值可能发生碰撞，如何解决呢？\n拉链法 每个散列值存一个链表（结构就很像邻接表了）。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  #include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100003; int h[N], e[N], ne[N], idx; void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); memset(h, -1, sizeof h); while (n -- ) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); if (*op == \u0026#39;I\u0026#39;) { insert(x); } else { if (find(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; }   开放寻址法 通过让N增大减少碰撞。 并在每次碰撞发生时向后找空位（这是放的时候）。 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 200003, null = 0x3f3f3f3f; int h[N]; int find(int x) { int t = (x % N + N) % N; while (h[t] != null \u0026amp;\u0026amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } int main() { memset(h, 0x3f, sizeof h); int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while (n -- ) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); if (*op == \u0026#39;I\u0026#39;) { h[find(x)] = x; } else { if (h[find(x)] == null) puts(\u0026#34;No\u0026#34;); else puts(\u0026#34;Yes\u0026#34;); } } return 0; }   ","date":"2022-04-21T21:24:00+08:00","permalink":"https://www.pythoner.work/post/ds001-hashtable/","title":"哈希表"},{"content":"循环队列 功能 节省空间。\n普通队列用过的空间不能用了，循环队列可以重复利用。\n1  push(1); pop(); push(2); pop();   代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  #include \u0026lt;iostream\u0026gt; using namespace std; // 队列长度，可以自己修改。 const int N = 10; // 队列 struct Queue { int q[N]; int hh = 1, tt = 0; void push(int x) { q[( ++ tt) % N] = x; if (hh / N \u0026amp;\u0026amp; tt / N) { hh -= (int)min(hh / N, tt / N) * N; tt -= (int)min(hh / N, tt / N) * N; } } void pop() { hh ++ ; } int front() { return q[hh % N]; } int back() { return q[tt % N]; } bool empty() { return hh \u0026gt; tt; } int size() { return tt - hh + 1; } }; // 调试 int main() { Queue q; q.push(1); q.pop(); q.push(1); q.push(2); cout \u0026lt;\u0026lt; (q.empty() ? \u0026#39;Y\u0026#39; : \u0026#39;N\u0026#39;) \u0026lt;\u0026lt; endl; q.push(3); q.pop(); q.pop(); q.pop(); q.push(1); q.push(2); q.push(3); cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; q.back() \u0026lt;\u0026lt; endl; q.push(4); q.push(5); cout \u0026lt;\u0026lt; q.size(); q.push(6); q.pop(); q.pop(); q.pop(); q.pop(); q.pop(); q.pop(); return 0; }    UPD:2023-10-21\n ","date":"2022-04-19T15:25:00+08:00","permalink":"https://www.pythoner.work/post/algo001-circular-linked-list/","title":"循环队列"}]
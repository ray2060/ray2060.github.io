[{"content":"分数版杨辉三角 比如说像：\n1 2 3 4  1/4 1/4 1/4 1/4 2/4 1/4 ...   这一类的。\n我们已知它的特性有：\n 一行的和是上一行的2倍（不含第一行） 一个数是上面两个数的和（没有一个就等于另一个，第一个除外）  其实还可以发现更多。\n杨辉三角 科普一下 杨辉三角，是二项式系数在三角形中的一种几何排列，中国南宋数学家杨辉1261年所著的《详解九章算法》一书中出现。在欧洲，帕斯卡（1623\u0026mdash;-1662）在1654年发现这一规律，所以这个表又叫做帕斯卡三角形。帕斯卡的发现比杨辉要迟393年，比贾宪迟600年。\n杨辉三角是中国数学史上的一个伟大成就。\n   科普一下      中文名 杨辉三角   外文名 Pascal\u0026rsquo;s Triangle   别名 贾宪三角形、帕斯卡三角形   提出时间 约1050年   发现者 杨辉    用途及其特性  每个数等于它上方两数之和。 每行数字左右对称，由$1$开始逐渐变大。 第$n$行的数字有$n$项。 前$n$行共$\\frac{(1+n)n}{2}$个数。 第$n$行的$m$个数可表示为$C_{n-1}^{m-1}$，即为从$n-1$个不同元素中取$m-1$个元素的组合数。 第n行数字的和为$2^{n-1}$。 $$1=2^{1-1}$$ $$1+1=2^{2-1}$$ $$1+2+1=2^{3-1}$$ $$1+3+3+1=2^{4-1}$$ $$1+4+6+4+1=2^{5-1}$$ $$1+5+10+10+5+1=2^{6-1}$$ 斜线上数字的和等于其向左（从左上方到右下方的斜线）或向右拐弯（从右上方到左下方的斜线），拐角上的数字。 $$1+1=2$$ $$1+1+1=3$$ $$1+1+1+1=4$$ $$1+2=3$$ $$1+2+3=6$$ $$1+2+3+4=10$$ $$1+3=4$$ $$1+3+6=10$$ $$1+4=5$$ 将各行数字左对齐，其右上到左下对角线数字的和等于斐波那契数列的数字。 $$1$$ $$1$$ $$1+1=2$$ $$2+1=3$$ $$1+3+1=5$$ $$3+4+1=8$$ $$1+6+5+1=13$$ $$4+10+6+1=21$$ $$1+10+15+7+1=34$$ $$5+20+21+8+1=55$$  ","date":"2022-05-19T15:34:00+08:00","permalink":"https://www.pythoner.work/post/yanghui/","title":"杨辉三角"},{"content":"题目 题目链接：景区三角形\n解法 暴力解 直接找出三个点，进行check()，非常简单的思路。\n满分解 很明显，这是一个无向图，看数据范围可以看出应该用邻接表。\n暴力解的缺点在于可能挑出三个毫无关联的点，那就让每个点拥有1个$fa$，有了它的存在， 我们就得找这个图的生成树，因为起码得有个点是根才有$fa$的概念。\n假设遍历到的点是$cur$，找到相邻点$v$，那么我们只用看$fa$和$v$是否相邻了，变得非常简单， 复杂度降低了很多。\n最终，再来谈论一下实现，在判断是否相邻时，使用二分查找，进一步优化。\n放代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; const int N = 1e5 + 10; int n, m; bool st[N]; int a, b, c; vector\u0026lt;int\u0026gt; G[N]; struct Node { int x, fa; }; int main() { freopen(\u0026#34;triangle.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;triangle.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i ++ ) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } for (int i = 1; i \u0026lt;= n; i ++ ) { sort(G[i].begin(), G[i].end()); } // bfs  queue\u0026lt;Node\u0026gt; q; q.push(Node{1, -1}); st[1] = 1; while (!q.empty()) { Node cur = q.front(); q.pop(); bool flag = false; for (int i = 0; i \u0026lt; G[cur.x].size(); i ++ ) { int v = G[cur.x][i]; if (cur.fa != -1 \u0026amp;\u0026amp; st[v] \u0026amp;\u0026amp; v != cur.fa \u0026amp;\u0026amp; binary_search(G[v].begin(), G[v].end(), cur.fa)) { a = cur.fa; b = cur.x; c = v; if (a \u0026gt; b) swap(a, b); if (b \u0026gt; c) swap(b, c); if (a \u0026gt; b) swap(a, b); flag = true; break; } if (!st[v]) { st[v] = true; q.push(Node{v, cur.x}); } } if (flag) break; } printf(\u0026#34;%d %d %d \\n\u0026#34;, a, b, c); return 0; }   拓展：基本不使用STL完成这道题 手写邻接表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int h[N]; // 链表头 int e[M]; // 通往哪个点 int ne[M]; // 链表中下一个 int w[M]; // 边权 int idx; // 记录到第几条边  // 无权加边（有向） void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 有权加边（有向） void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; }   手写队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  int q[N], hh, tt; // q.empty() hh == tt // q.push(x); q[++ tt] = x; // q.front() q[hh + 1] // q.pop(); hh ++ ; // bfs模板 q[++ tt] = x; st[x] = true; while (hh != tt) { hh ++ ; if (check(q[hh])) { q[++ tt] = get(q[hh]); } }   完整代码 注：抛弃了二分，否则太复杂了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; const int N = 1e5 + 10; int n, m; bool st[N]; int a, b, c; int h[N], e[N], ne[N], idx; int q[N], fa[N], hh, tt; void add(int u, int v) { e[idx] = v, ne[idx] = h[u], h[u] = idx ++ ; } bool find(int u, int v) { for (int i = h[u]; i != -1; i = ne[i]) { if (e[i] == v) return true; } return false; } void swap(int \u0026amp;x, int \u0026amp;y) { int z = x; x = y; y = z; } int main() { memset(h, -1, sizeof h); freopen(\u0026#34;triangle.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;triangle.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i ++ ) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u, v); add(v, u); } q[++ tt] = 1; fa[tt] = -1; st[1] = 1; while (hh != tt) { hh ++ ; bool flag = false; for (int i = h[q[hh]]; i != -1; i = ne[i]) { int v = e[i]; if (fa[hh] != -1 \u0026amp;\u0026amp; st[v] \u0026amp;\u0026amp; v != fa[hh] \u0026amp;\u0026amp; find(fa[hh], v)) { a = fa[hh]; b = q[hh]; c = v; if (a \u0026gt; b) swap(a, b); if (b \u0026gt; c) swap(b, c); if (a \u0026gt; b) swap(a, b); flag = true; break; } if (!st[v]) { st[v] = true; q[++ tt] = v; fa[tt] = q[hh]; } } if (flag) break; } printf(\u0026#34;%d %d %d \\n\u0026#34;, a, b, c); return 0; }   ","date":"2022-05-01T21:07:00+08:00","permalink":"https://www.pythoner.work/post/sol-jisuanke-t3633/","title":"景区三角形"},{"content":"考试简介  题数：5道 时间：2个小时 总分：500分 难度：低于CSP-J  题目 ABC题没难度，忽略。\nD：购机攻略 链接：购机攻略\n思路 直接模拟，由于sort()只能排序单个内容，不能排序散的内容，用struct。\n易错点 sort()只能排序单个内容，不能排序散的内容，用struct。\nE：暑假作业 链接：暑假作业\n思路 和二分求一个数的立方根这类的题相似，就用二分。\n可以知道答案最少是1，至多是最大的元素，在这两个值中间二分。\n易错点 容易想不到要二分……\n总结 不能不拿部分分 DE两题是放弃了，所以得了300分，如果拿部分分就是360分，多了足足60分！！！\n要有思考，不能光是暴力 很多算法都是先想暴力做法及其缺点再进行优化，我们也要学习。\n不能想问题想的过于死板 D题根本就没想到sort()不能排散东西。\n","date":"2022-04-23T18:00:00+08:00","permalink":"https://www.pythoner.work/post/xiaotuling-202204/","title":"有道小图灵3级（2022年4月）"},{"content":"比赛简介  题数：4道 时间：2个小时 总分：400分 难度：和CSP-J2难度相当  开始考试 先来讲题。\nA题签到题忽略……\nB：完美数列 题目链接：完美数列\n暴力解法 直接找最大值砍下去。\n60分解法（实际90分） 使用priority_queue来找最大值，一层一层砍。\n满分解 二分答案法，非常简洁！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long LL; const int N = 1e6 + 10; int n, p; LL w, s[N]; int a[N]; bool check(int x) { int idx = upper_bound(a, a + n, x) - a; LL len = n - idx; LL tmp = s[idx] - len * x; return tmp \u0026lt;= w / p; } int main() { freopen(\u0026#34;money.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;money.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p \u0026gt;\u0026gt; w; for (int i = 0; i \u0026lt; n; i ++ ) cin \u0026gt;\u0026gt; a[i]; sort(a, a + n); for (int i = n - 1; i \u0026gt;= 0; i -- ) { s[i] = s[i + 1] + a[i]; } int l = 0, r = 1e9 + 10; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) { r = mid; } else { l = mid + 1; } } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; return 0; }   C：传递 题目链接：传递\n40分 冒泡排序，边排边计算代价，非常暴力……\n满分解 这是带权逆序对问题。\n所以通过归并求逆序对，从$p_2$移到$p_1$需要耗费代价\n$((p_2 + mid)^2 + (p_2 + mid - 1)^2 + \u0026hellip; + (p_2 + p_1)^2) + (2 * w[mid] * w[p_2] + 2 * w[mid - 1] * w[p_2] + \u0026hellip; + 2 * w[p_1] * w[p_2]) + (mid - p_1 + 1) * w[p_2]$\n然后，维护$w[i]$和$w[i] ^ 2$的后缀和就OK了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long LL; const int N = 5e5 + 10, P = 1e9 + 7; int n; int w[N], p[N]; int a[N], b[N]; LL sum1[N], sum2[N]; LL ans; void merge(int l, int r) { int mid = (l + r) \u0026gt;\u0026gt; 1; int p1 = l, p2 = mid + 1; int m = l; sum1[mid + 1] = sum2[mid + 1] = 0; for (int i = mid; i \u0026gt;= l; i -- ) { sum1[i] = (sum1[i + 1] + w[i]) % P; sum2[i] = (sum2[i + 1] + ((LL)w[i] * w[i]) % P) % P; } while (p1 \u0026lt;= mid \u0026amp;\u0026amp; p2 \u0026lt;= r) { if (p[p1] \u0026lt;= p[p2]) { b[m] = w[p1]; a[m ++ ] = p[p1 ++ ]; } else { ans = (ans + sum2[p1]) % P; ans = (ans + 2 * sum1[p1] * w[p2] % P) % P; ans = (ans + (LL)(mid - p1 + 1) * w[p2] * w[p2] % P) % P; b[m] = w[p2]; a[m ++ ] = p[p2 ++ ]; } } while (p1 \u0026lt;= mid) { b[m] = w[p1]; a[m ++ ] = p[p1 ++ ]; } while (p2 \u0026lt;= r) { b[m] = w[p2]; a[m ++ ] = p[p2 ++ ]; } for (int i = l; i \u0026lt;= r; i ++ ) { p[i] = a[i]; w[i] = b[i]; } } void msort(int l, int r) { if (l == r) { return; } int mid = (l + r) \u0026gt;\u0026gt; 1; msort(l, mid); msort(mid + 1, r); merge(l, r); } int main() { freopen(\u0026#34;transfer.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;transfer.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i ++ ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i]); } for (int i = 1; i \u0026lt;= n; i ++ ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;p[i]); } msort(1, n); printf(\u0026#34;%lld\u0026#34;, ans); return 0; }   D：景区三角形 题目链接：景区三角形\n暴力解法 就$O(n^3)$找三个点，做个check()，就结束了，不再赘述。\n满分解 通过bfs找三角形，一个点设一个$fa$，根（1）等于$-1$。\n有点像找生成树。\n找到一个点$v$，判断$fa$，$cur$，$v$是否构成三角形，如果是，排序放进答案里输出，如果$v$没遍历过，遍历$v$。\n这道题我写了更详细的题解（代码也包装进去了，这里不放了哈）： 题解-景区三角形\n总结 不能放弃，记得调试 C题本来能40分的，但是没调试，放弃了，代码都没存档……\n注意亿些关于输入输出的低级问题 赛后调试一道题时发现有问题，结果，没想到，freopen忘记注释了……\n要用草稿纸 不用草稿纸基本只能做签到题，有些考试中的B题可能也不难，也能做出来。 关于C题的推导其实很长这件事……\n想算法时的方法很重要 签到题如果复杂度不超标就行，这回也就简简单单一个快速幂。\n其他题可以由复杂度推出算法，或是从暴力法开始优化，都可以。\n","date":"2022-04-23T15:00:00+08:00","permalink":"https://www.pythoner.work/post/jisuanke-202204/","title":"计蒜客4月月赛（普及组）"},{"content":"功能 1 2 3 4  add(8); add(9); find(10); // false find(8); // true   实现 首先，写一个散列函数。\n1 2 3  int get(int x) { return (x % N + N) % N; // 解决负数问题 }   接着，就出现了问题，散列值可能发生碰撞，如何解决呢？\n拉链法 每个散列值存一个链表（结构就很像邻接表了）。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  #include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100003; int h[N], e[N], ne[N], idx; void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); memset(h, -1, sizeof h); while (n -- ) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); if (*op == \u0026#39;I\u0026#39;) { insert(x); } else { if (find(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; }   开放寻址法 通过让N增大减少碰撞。 并在每次碰撞发生时向后找空位（这是放的时候）。 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 200003, null = 0x3f3f3f3f; int h[N]; int find(int x) { int t = (x % N + N) % N; while (h[t] != null \u0026amp;\u0026amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } int main() { memset(h, 0x3f, sizeof h); int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while (n -- ) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); if (*op == \u0026#39;I\u0026#39;) { h[find(x)] = x; } else { if (h[find(x)] == null) puts(\u0026#34;No\u0026#34;); else puts(\u0026#34;Yes\u0026#34;); } } return 0; }   STL（建议使用） 代码都不用上了……\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;iostream\u0026gt;#include \u0026lt;unordered_map\u0026gt; using namespace std; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); unordered_map\u0026lt;int, bool\u0026gt; h; while (n -- ) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); if (*op == \u0026#39;I\u0026#39;) { h[x] = true; } else { if (h[x] == false) puts(\u0026#34;No\u0026#34;); else puts(\u0026#34;Yes\u0026#34;); } } return 0; }   ","date":"2022-04-21T21:24:00+08:00","permalink":"https://www.pythoner.work/post/hashtable/","title":"哈希表"},{"content":"循环队列 功能 节省空间，比如说：\n操作：\n1  push(1); pop(); push(2); pop();   效果： hh以前的空间不能用了。\n用循环队列可以把队列拉成数组的长度，而普通队列不一定。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  #include \u0026lt;iostream\u0026gt; using namespace std; // 队列长度，可以自己修改。 const int N = 10; // 队列 struct Queue { int q[N]; int hh = 1, tt = 0; void push(int x) { q[( ++ tt) % N] = x; if (hh / N \u0026amp;\u0026amp; tt / N) { hh -= (int)min(hh / N, tt / N) * N; tt -= (int)min(hh / N, tt / N) * N; } } void pop() { hh ++ ; } int front() { return q[hh % N]; } int back() { return q[tt % N]; } bool empty() { return hh \u0026gt; tt; } int size() { return tt - hh + 1; } }; // 调试 int main() { Queue q; q.push(1); q.pop(); q.push(1); q.push(2); cout \u0026lt;\u0026lt; (q.empty() ? \u0026#39;Y\u0026#39; : \u0026#39;N\u0026#39;) \u0026lt;\u0026lt; endl; q.push(3); q.pop(); q.pop(); q.pop(); q.push(1); q.push(2); q.push(3); cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; q.back() \u0026lt;\u0026lt; endl; q.push(4); q.push(5); cout \u0026lt;\u0026lt; q.size(); q.push(6); q.pop(); q.pop(); q.pop(); q.pop(); q.pop(); q.pop(); return 0; }   版权问题 没有问题，背着抱着都行。\n评论区问题 评论区不能抱走， sofa你是背不动滴，给我一句留言我就让你抱走。\n","date":"2022-04-19T15:25:00+08:00","permalink":"https://www.pythoner.work/post/circular-linked-list/","title":"循环队列"}]
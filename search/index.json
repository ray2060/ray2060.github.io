[{"content":"更新记录 [2024-08-26 22:03] 完成了 \u0026lt;商品交易\u0026gt; 和 \u0026lt;纸牌游戏\u0026gt; 的题解与感受。\n[2024-08-27 15:08] 完成了 \u0026lt;交流问题\u0026gt; 的题解与感受，并提供了所有题目的正确代码。\n[2024-08-27 21:58] 完成了 \u0026lt;俄罗斯方块\u0026gt; 的题解与感受，补充了 \u0026lt;纸牌游戏\u0026gt; 的感受。\n[2024-08-28 16:34] 完成了 \u0026lt;黑白翻转\u0026gt; 和 \u0026lt;区间乘积\u0026gt; 的题解与感受，完结撒花。\n[2024-08-28 16:53] 补充了 \u0026lt;总结\u0026gt; 部分。\n正确代码 洛谷 - 云剪贴板，Github - Gist\n商品交易 202312 A 洛谷题库 P10110\n题解 本质上是求一个边权为 $1$ 的最短路。每进行一次交换，总资产就会少 $1$ 元。\n根据题意，用手上的第 $x$ 种商品交换第 $y$ 种商品，花费 $v_y - v_x + 1$ 元，总资产变化为 $-v_x + v_y - (v_y - v_x + 1) = -1$。（$-v_x$ 是第 $x$ 件商品没了，$+v_y$ 同理）\n最后加上期望获得的商品的价格 $v_b$ 与原本持有的商品的价格 $v_a$ 的差即可。\n感受 非常巧妙的一道最短路问题，算是一个简化版的 SPFA（由于边权为 $1$，所以不需要 st 数组防止重复入队）。\n放段代码比较一下：\nSPFA 模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  int spfa() { memset(dist, 0x3f, sizeof dist); queue\u0026lt;int\u0026gt; q; dist[1] = 0; st[1] = true; q.push(1); while (!q.empty()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) { q.push(j); st[j] = true; } } } } if (dist[n] == INF) return INF; return dist[n]; }   本题正解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  int main() { /* ... v 数组有必要存的只有 v[a], v[b] 所以用 va, vb 两个 int 替代 */ queue\u0026lt;int\u0026gt; q; q.push(a); st[a] = 1; dist[a] = 0; while (!q.empty()) { int t = q.front(); q.pop(); if (t == b) { break; } for (int i = h[t]; ~i; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + 1) { dist[j] = dist[t] + 1; q.push(j); } } } if (dist[b] != INF) { cout \u0026lt;\u0026lt; vb - va + dist[b] \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;No solution\u0026#34;; } return 0; }   数据量有点迷惑性，$10^5$ 对应的时间复杂度 $O(n\\log n)$ 让人联想到 Dijkstra 等算法，然后发现实际上是一个 $O(n)$ 的 BFS。\n此题难度不高，出题组第一次出七级的题可能把握不住题目难度，不作七级题目难度参考。\n纸牌游戏 202312 B 洛谷题库 P10111\n题解 经典最值问题，有非常浓厚的状态转移风味，并且无后效性，考虑 DP。\n 状态表示 f[i][j][k] 表示在第 $i$ 轮出了牌 $j$、累计换牌（额外扣分） $k$ 次时可以获得的最高分数。 状态计算 f[i][j][k] = max(f[i - 1][t][k + ((j == t) ? 0 : -1)])，其中 $t \\in \\lbrace 0, 1, 2 \\rbrace$。  最后取所有 $j \\in \\lbrace 0, 1, 2 \\rbrace , 0 \\leq k \\le n$ 的 f[n][j][k] - b[k] 的最大值（b[k] 为额外扣分数组的前缀和）。\n注：可以把 f 数组的第一维压掉，但不差这点空间。\n感受  做代码优化时，别的不用考虑，只要保证做的是等价变形。——yxc\n DP 的状态表示基本靠硬想，唯一的技巧就是题里有啥就写啥，想到什么表示方法就试试，不行的话就尝试增加或减少一个维度之类的。\n偶尔做题时会发现一些有意思的小事情，比如每轮得分可以表示为 ((c[i] == j) ? a[i] : (2 * ((c[i] + 3 - j) % 3 - 1) * a[i]))（c[i] 为对手出牌，j 为我方出牌，a[i] 为本局分数），然后你就会发现这玩意完全没用。\n如果状态转移想的不太清楚的话，会产生大量复制粘贴，最终码量在 2KB 左右，找规律可以减少一些复制粘贴，可以降到 1KB 码量。\n本题难度中等，状态表示很难，算是一道优秀的 DP 题。\n交流问题 202403 A 洛谷题库 P10378\n题解 A 校和 B 校很明显是一个二分图的两部分。每个连通块都有两种分学校的方案，可以通过染色法分出学校，左右两半分别是 A B 校或 B A 校，两种方案产生了两组“该连通块中 A 校人数和 B 校人数”，记录两组中较小的 B 校人数（其实 B 校还是 A 校没区别，所以也可以只求一组，取两校人数的最小值）。仅需计算该二分图所有的连通块的“较小的 B 校人数”之和，该数是 B 校总人数的最小值，用 $n$ 减去该数就是 B 校总人数的最大值（即 A B 校学生数互换）。\n感受 二分图明显就明显在所有边（交流）都在两学校之间，学校内不连边。每个连通块内的集合（学校）划分就是给每个点（学生）打标签，与染色法十分相似。\n很水，感觉思考深度和前两题完全不是一个级别（话好像说反了）。\n俄罗斯方块 202403 B 洛谷题库 P10379\n题解 用类似于 floodfill 的算法解决，固定从每个俄罗斯方块左上角开始搜索，这样就可以使每个方块拥有一个固定的有根搜索树，相同形状的俄罗斯方块搜索树也相同，把遍历顺序（层序遍历，树上 DFS 等）当作这个类型的俄罗斯方块独一无二的标识。\n用 set 的去重功能统计有多少种遍历顺序，即有多少种俄罗斯方块。\n感受 floodfill 的特征还算明显，难就难在如何表示每个俄罗斯方块。这么做我是完全没想到的，看别人的题解看到的。遍历顺序是一个搜索的过程中就产生的东西，不增加复杂度，可能是一个比较容易发现的算法，但是我没发现。\n巧妙的搜索题，难度的话，中等？\n黑白翻转 202406 A 洛谷题库 P10723\n题解 我们发现，只有连接两个及以上黑色节点的白色节点才需要染黑。白色叶节点并不能连接黑色节点，没有必要染成白色，所以循环删除所有白色叶节点。最后统计剩下的白色节点数并输出，因为最后剩下的白色节点都是需要染成黑色的。\n注：无根树的叶节点的定义是度数不大于 $1$ 的点。\n感受 难度中等。\n思路就是连接黑色节点，其余白色全部删除。容易走到歪路上，像是 DFS 之类（有可能路没歪但是我想不明白）。\n区间乘积 202406 B 洛谷题库 P10724\n题解 容易发现：一个数是完全平方数时，它的所有质因子的指数都为偶数。\n在质因数分解的过程中，我们可以通过状态压缩来存储每个质因子的指数的奇偶性，每一个二进制位代表一个质因子，这一位为 $1$ 的含义是其对应的质因子的指数是偶数，反之亦然。判断区间乘积是否为完全平方数可以通过该区间质因数分解结果的异或和是否为 $0$ 来判断。\n建立 f 数组，记录区间异或和出现次数，答案就是重复区间异或和出现的次数。\n感受 难度简单。\n当我们发现要记录奇偶性，又是加起来的时候，就可以想到异或以及状态压缩。\n重复区间异或和出现次数这一点比较难想。\n总结 整体难度略高，不稳定。\n考的算法是搜索、图论、DP、数学 这几类，其中 DP 和数学很难。\n","date":"2024-08-26T22:03:00+08:00","permalink":"https://www.pythoner.work/post/exp004-gesp-7/","title":"GESP7级做题经验及题解"},{"content":"现象 1 2 3 4 5 6 7 8  print(8 % 3) print(4 % 7) print(-8 % 3) print(-4 % 7) print(8 % -3) print(4 % -7) print(-8 % -3) print(-4 % -7)   在 Python 中，运行以上程序的结果是：\n1 2 3 4 5 6 7 8  2 4 1 3 -1 -3 -2 -4   在 C++ 中，编写看起来意思一样的程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; 8 % 3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; 4 % 7 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; -8 % 3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; -4 % 7 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; 8 % -3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; 4 % -7 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; -8 % -3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; -4 % -7 \u0026lt;\u0026lt; endl; return 0; }   然而，两个程序的运行结果不一样。下面是 C++ 程序的结果。\n1 2 3 4 5 6 7 8  2 4 -2 -4 2 4 -2 -4   分析 整理数据 整理一下数据，列个表格。\n   算式 Python 结果 C++ 结果     $8 \\bmod 3$ $2$ $2$   $4 \\bmod 7$ $4$ $4$   $-8 \\bmod 3$ $1$ $-2$   $-4 \\bmod 7$ $3$ $-4$   $8 \\bmod -3$ $-1$ $2$   $4 \\bmod -7$ $-3$ $4$   $-8 \\bmod -3$ $-2$ $-2$   $-4 \\bmod -7$ $-4$ $-4$    原因 两种语言给出不同的结果的原因是这两种语言执行除法的方式不同。（欧几里得除法：a = b * q + r，a 为被除数，b 为除数，q 为商，r 为余数）\n Python 采用的方法是：向负无穷方向舍入，即让商更小（但需保证 $-|b| \\le r \\le |b|$）。 C++ 采用的方法是：向零舍入，即让商更靠近零（但需保证 $-|b| \\le r \\le |b|$）。  举个例子 1 2 3 4 5  -8 / 3 Python: -8 = 3 * -3 + 1 C++: -8 = 3 * -2 - 2   1 2 3 4 5  4 / -7 Python: 4 = -7 * -1 - 3 C++: 4 = -7 * 0 + 4   拓展 如何让余数变为非负整数 保证余数为非负整数只需 $((a \\bmod b) + b) \\bmod b$。\n","date":"2024-08-10T11:04:00+08:00","permalink":"https://www.pythoner.work/post/exp003-mod/","title":"C++和Python的取模的区别"},{"content":"算术形式 表达“三与四相加”时，前缀记法（即波兰表达式）写作 +34，中缀记法写作 3+4，后缀记法（即逆波兰表达式）写作 34+。 中缀表达式 (1-2)*3 的前缀记法为 *-123，后缀记法为 12-3*。\n请注意，逆波兰表达式不是把波兰表达式反转。\n运算波兰表达式时，无需记住运算的层次，只需要直接寻找第一个运算的操作符。以二元运算为例，从左至右读入表达式，遇到一个操作符后跟随两个操作数时，则计算之，然后将结果作为操作数替换这个操作符和两个操作数；重复此步骤，直至所有操作符处理完毕。\n逆波兰表达式的解释器一般是基于堆栈的。解释过程一般是：操作数入栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。\n由于简单运算符都是二元的，所以波兰表达式与逆波兰表达式不需要括号。\n例子  前缀表达式  1 2 3 4 5  - / * + 5 7 3 6 4 = - / * 12 3 6 4 = - / 36 6 4 = - 6 4 = 2   1 2 3 4  + - 6 * 4 5 2 = + - 6 20 2 = + -14 2 = -12    后缀表达式  1 2 3 4 5  5 7 + 3 * 6 / 4 - = 12 3 * 6 / 4 - = 36 6 / 4 - = 6 4 - = 2   1 2 3 4  6 4 5 * - 2 + = 6 20 - 2 + = -14 2 + = -12   ","date":"2024-08-10T10:31:00+08:00","permalink":"https://www.pythoner.work/post/math001-polish-notation/","title":"波兰表示法与逆波兰表示法"},{"content":"Day -1 摆烂。\n忘记查哪个考场了。\nDay 0 7:30 乘坐出租车（拼车？）前往rdfz。\n8:15 进考场，听不明白监考老师在说什么。\n花了3分钟才把回收系统的地址抄下来，然后发现坐错了。\n8:26 发了试题，看题……\n我喜欢把四道题分别叫成 ABCD，结果发现第一题叫 Apple，第四题叫 Bus……\n9:12 提交 AB 两题。\n觉得 200 分起步。\n11:12 搞不明白 C，拿点部分分走人。\n11:47 交了 D，觉得在 C 上浪费时间太多了，不然可以写正解 dij 的。\n12:00 离场，前往麦吃午饭。\n排大队啊！离谱！\n最后总算吃上了。\n14:00 进考场。rdf风景不错。\n不让带食品和水。\n15:15 开始摆烂……\n太难了吧！\n至少能保证把 A 过掉。\n18:30 考完了，啃带来的巧克力。\n18:40 rdfz夜景真的很好看，可惜没带手机。\n出了考场才知道前年CSP是在这考的。\nJ 组估分 $130$。\n未完待续 ","date":"2023-10-21T21:25:00+08:00","permalink":"https://www.pythoner.work/post/tn004-csp-2023-second/","title":"CSP 2023 游记"},{"content":"Day -1 确定考场：北京市第八十中学\n啊这……去过不知道多少遍了……\nDay 0 9:30 发卷。\n钉在一起了？这……不太好翻吧？\n11:10 做完了，觉得没什么好检查的了，直接涂答题卡。\n迷惑身边的学长怎么涂了半小时。\n11:30 考完了，经典收卷不能离开座位。\n14:30 时间挺紧，继续考S组。\n15:10 已经把会做的题都做完了，决定开始涂答题卡。\n15:45 欣赏风景……^_^\n16:30 交卷，轻松。\n比去年只打J组还轻松。\n17:30 J组估分 $69$，比去年低了 $10$ 分！\n不应该啊，今年题比去年简单 $10$ 倍。\nDay 1 周日，原神？启动！。\nS组估分 $47.5$，正常，毕竟我也没认真答。\nDay ? 最后成绩：\n   CSP-J CSP-S     66 52.5   晋级 晋级   ?等奖 ?等奖    ","date":"2023-09-17T09:14:00+08:00","permalink":"https://www.pythoner.work/post/tn003-csp-2023-first/","title":"CSP 2023 游记"},{"content":"爆掉出现的问题 此处使用爆int举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026lt;iostream\u0026gt; using namespace std; bool check(int x) { return x \u0026gt; 1919810; } int main() { int l = 114514, r = 2.14748e9; while ((r - l) \u0026gt; 1) { // 1.  int mid = (l + r) / 2; // 2.  int mid = l + (r - l) / 2; if (check(mid)) { r = mid; } else { l = mid + 1; } } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; return 0; }   结果是：\n使用1号代码输出-1073686390，使用2号代码输出1919810。\n为什么它等于mid $L+\\frac{R-L}{2} = \\frac{2L + R - L}{2} = \\frac{L + R}{2}$\n就是l和r的平均值mid。\n为什么不会爆 首先，一般的二分答案都是二分正数（不是的话，答案范围一般不大，如浮点二分三次方根），那r - l就不会爆。\nr - l不爆，(r - l) / 2也不会爆。\n至于l + (r - l) / 2，很明显，这个值一定在l和r之间，既然l和r不爆，那这个就不可能爆。\n总结 当然，除非真的要爆long long了才会用这招，不然写错了可就爆0了。\n注：写二分也要注意边界条件哈，听说只有 $10%$ 的程序员能写对二分hhh。\n附：整型浮点型爆炸极限    类型名 二分爆炸极限 EPS建议值     int $l = 0, r = 10^{9}$ ???   long long $l = 0, r = 4.6 \\times 10^{18}$ ???   double ??? $10^{-8}$ 一般就用 $10^{-5}$（可存15位十进制）   long double ??? $10^{-26}$ 一般不用太精确，所以 $10^{-15}$ 就差不多（可存33位十进制）    ","date":"2022-10-23T14:07:00+08:00","permalink":"https://www.pythoner.work/post/exp002-bs-ll-overflow/","title":"二分爆long long解决方法"},{"content":"Day -2 今天做了个模拟，成绩65，一般般。最主要的是保持一个好状态准备迎接J1。\nDay -1 小图灵集训队集训日。今天终于能从J1的思维中跳出来放松一下了！\nDay 0 7:30 起床了！洗把脸清醒一下。\n8:10 坐上出租车冲向考场！路上复习一下排序的稳定性。\n8:45 到达考场所在大厦的楼底下。\n验证身份后拿起袋子爬楼，要爬7楼。\n走进考场，好紧张好紧张。没想到能遇到同学校的学长，心放下来了一半。\n9:30 发卷。\n拿到卷子，先浏览一遍，可以看出没有组合数学，位运算放到了阅读程序第一题，阅读第二三题看起来很难，要多分配时间，补全程序很简单，枚举和floodfill。\n11:00 做完了，还要检查。\n居然出租车上复习都能压中题，欧皇附身了！\n11:30 下楼啦，心全放下来了。\n19:00 直播时间到！\n没想到考后7小时就出估分了，77不是太好。能现场听题解，所有不懂的地方全懂了。\nDay 1 周一，上学。\n上课就只有两个字，好困！\nDay 3 估分更正，79。\n这道题到底说的是强连通还是弱联通？！\n9.考虑由 $N$ 个顶点构成的有向连通图，采用邻接矩阵的数据结构表示时，该矩阵中至少存在（ ）个非零元素。\nA $N - 1$\nB $N$\nC $N + 1$\nD $N^2$\nDay 9 出成绩啦，77又变回去了哈哈哈。\n晋级，是肯定的，毕竟我在北京。\n可以冲J2啦。\n","date":"2022-09-18T15:00:00+08:00","permalink":"https://www.pythoner.work/post/tn001-csp-2022-first/","title":"CSP-J1 2022 参赛经历"},{"content":"问题 代码 1 2 3 4 5  vector\u0026lt;int\u0026gt; vec; // some code here for (int i = 0; i \u0026lt; vec.size() - 1; i ++ ) { cout \u0026lt;\u0026lt; vec[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; }   原本思路 只打印$vec$的前$|vec| - 1$个元素，就用这个挺好！\n显示出的问题 Segmentation Fault 11/0/11\n解读 1 2  C:/blahblah/blahblahblah.cpp:2022:23: warning: comparison of integer expressions of different signedness: \u0026#39;int\u0026#39; and \u0026#39;std::vector\u0026lt;int\u0026gt;::size_type\u0026#39; {aka \u0026#39;long long unsigned int\u0026#39;} [-Wsign-compare] for (int i = 0; i \u0026lt; vec.size(); i ++ ) {   可以发现如果size是$0$那么就会减出$18446744073709551615$，明显是要报错的。\n","date":"2022-08-11T14:38:00+08:00","permalink":"https://www.pythoner.work/post/exp001-unsigned-no-sub1/","title":"size_t相当于unsigned long long"},{"content":"目的 求$m ^ k$ $\\bmod$ $p$\n反复平方法 预处理 $O(k)$预处理出来以下的数：\n$m ^ {2 ^ 0}$ $\\bmod$ $p$\n$m ^ {2 ^ 1}$ $\\bmod$ $p$\n$m ^ {2 ^ 2}$ $\\bmod$ $p$\n\u0026hellip;\n$m ^ {2 ^{\\log{k}}}$ $\\bmod$ $p$\n怎么做？直接循环！代码忽略，因为还要优化。\n算答案 举例子，$4 ^{5}$ $\\bmod$ $10$ $ = (4^{2 ^ 2}$ $\\bmod$ $10$ $\\times$ $4 ^{2 ^ 0}$ $\\bmod$ $10)$ $\\bmod$ $10$\n就可以调预处理的数了，\n$4^{2 ^ 2}$ $\\bmod$ $10$ $ = $ $6$\n$4^{2 ^ 0}$ $\\bmod$ $10$ $ = $ $4$\n$(6$ $\\times$ $4)$ $\\bmod$ $10$ $ = $ $4$\n验证一下：\n$4^5$ $\\bmod$ $10$ $=$ $1024$ $\\bmod$ $10$ $=$ $4$\n把$k$转化为二进制并取出对应的数再相乘，$O(k)$。\n把两个步骤合在一起 1 2 3 4 5 6 7 8 9  int qmi(int m, int k, int p) { int t = 1 % p; while (k) { if (k \u0026amp; 1) t = (LL)t * m % p; m = (LL)m * m % p; k \u0026gt;\u0026gt;= 1; } return t; }   关键操作：\n k \u0026amp; 1 $k$ 的末位（二进制）为$0$ LL 乘的过程可能会爆int，使用long long  至此，模板题就可以$\\Large{\\color{green}{AC}}$辣！\n应用题 幂次方 题面 对任意正整数 $N$，计算 $X^N \\bmod 233333$ 的值。\n（输入输出不用管他）\n解法 把$233333$看作$p$，彻头彻尾的一道快速幂题。\nqmi(X, N, 233333)\n越狱 题面 监狱有连续编号为 $1$ 到 $n$ 的 $n$ 个房间，每个房间关押一个犯人。\n有 $m$ 种宗教，每个犯人可能信仰其中一种。\n如果相邻房间的犯人信仰的宗教相同，就可能发生越狱。\n求有多少种状态可能发生越狱，对 $100003$ 取余。\n解法 直接想发生越狱的情况数不好想，那就想不发生越狱，$1$有$n$钟选择，$2$要想不发生越狱需要避开$1$的选择，有$n - 1$钟，后面的每一个人都需要避开前面一人的选择，都是$n - 1$种选择。列算式： $$m (m - 1)^{n-1}$$ 那不越狱的方案数就是： $$m^n - m(m - 1)^{n - 1}$$ 用快速幂解决问题。\n","date":"2022-08-11T11:56:00+08:00","permalink":"https://www.pythoner.work/post/algo002-qmi/","title":"快速幂"},{"content":"不放回（无重排列组合） 有序 $$P_n^m$$\n无序 $$C_n^m$$\n放回（可重排列组合） 有序 一个一个取，每步可以有$n$种选择，乘法原理： $$n \\times n \\times n \\times\u0026hellip;\\times n\\ = n^m$$\n无序 可重组合，可记作： $\\bar{C}_n^m$（c bar n m)， $H_n^m$。\n重点：隔板法\n从$n$元集中可重复的选取$m$个元素，则方程$x_1 + x_2 + x_3 + \u0026hellip; + x_n = m$的非负整数解的个数就是可以选的方式的总个数。那么我们可以把这个问题看成在$m$个元素中插入$n-1$个分隔符，每段中是一种元素，就是在$n+m-1$个位置中选取$n-1$个放分隔符，也是$n+m-1$个位置中选取$m$个不放分隔符，就可以用无重组合的方式表示可重组合： $$C_{n+m-1}^{m}$$\n无序，每种至少选一个 可重组合的变形，仍使用隔板法。\n这次每种至少选一个的使得两个隔板不能放在一起，位置数减小到了$m - 1$，所以答案就是： $$C_{m-1}^{n-1}$$\n","date":"2022-07-10T11:52:00+08:00","permalink":"https://www.pythoner.work/post/comb001-counting/","title":"从n个球中取m个"},{"content":"题目 题目链接：景区三角形\n解法 暴力解 直接找出三个点，进行check()，非常简单的思路。\n满分解 很明显，这是一个无向图，看数据范围可以看出应该用邻接表。\n暴力解的缺点在于可能挑出三个毫无关联的点，那就让每个点拥有1个$fa$，有了它的存在， 我们就得找这个图的生成树，因为起码得有个点是根才有$fa$的概念。\n假设遍历到的点是$cur$，找到相邻点$v$，那么我们只用看$fa$和$v$是否相邻了，变得非常简单， 复杂度降低了很多。\n最终，再来谈论一下实现，在判断是否相邻时，使用二分查找，进一步优化。\n放代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;vector\u0026gt; using namespace std; const int N = 1e5 + 10; int n, m; bool st[N]; int a, b, c; vector\u0026lt;int\u0026gt; G[N]; struct Node { int x, fa; }; int main() { freopen(\u0026#34;triangle.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;triangle.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i ++ ) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; G[u].push_back(v); G[v].push_back(u); } for (int i = 1; i \u0026lt;= n; i ++ ) { sort(G[i].begin(), G[i].end()); } // bfs  queue\u0026lt;Node\u0026gt; q; q.push(Node{1, -1}); st[1] = 1; while (!q.empty()) { Node cur = q.front(); q.pop(); bool flag = false; for (int i = 0; i \u0026lt; G[cur.x].size(); i ++ ) { int v = G[cur.x][i]; if (cur.fa != -1 \u0026amp;\u0026amp; st[v] \u0026amp;\u0026amp; v != cur.fa \u0026amp;\u0026amp; binary_search(G[v].begin(), G[v].end(), cur.fa)) { a = cur.fa; b = cur.x; c = v; if (a \u0026gt; b) swap(a, b); if (b \u0026gt; c) swap(b, c); if (a \u0026gt; b) swap(a, b); flag = true; break; } if (!st[v]) { st[v] = true; q.push(Node{v, cur.x}); } } if (flag) break; } printf(\u0026#34;%d %d %d \\n\u0026#34;, a, b, c); return 0; }   拓展：基本不使用STL完成这道题 链式前向星 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  int h[N]; // 链表头 int e[M]; // 通往哪个点 int ne[M]; // 链表中下一个 int w[M]; // 边权 int idx; // 记录到第几条边  // 无权加边（有向） void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 有权加边（有向） void add(int a, int b, int c) { e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ; }   手写队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  int q[N], hh, tt; // q.empty() hh == tt // q.push(x); q[++ tt] = x; // q.front() q[hh + 1] // q.pop(); hh ++ ; // bfs模板 q[++ tt] = x; st[x] = true; while (hh != tt) { hh ++ ; if (check(q[hh])) { q[++ tt] = get(q[hh]); } }   完整代码 注：抛弃了二分，否则太复杂了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt; using namespace std; const int N = 1e5 + 10; int n, m; bool st[N]; int a, b, c; int h[N], e[N], ne[N], idx; int q[N], fa[N], hh, tt; void add(int u, int v) { e[idx] = v, ne[idx] = h[u], h[u] = idx ++ ; } bool find(int u, int v) { for (int i = h[u]; i != -1; i = ne[i]) { if (e[i] == v) return true; } return false; } void swap(int \u0026amp;x, int \u0026amp;y) { int z = x; x = y; y = z; } int main() { memset(h, -1, sizeof h); freopen(\u0026#34;triangle.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;triangle.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; m; i ++ ) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; add(u, v); add(v, u); } q[++ tt] = 1; fa[tt] = -1; st[1] = 1; while (hh != tt) { hh ++ ; bool flag = false; for (int i = h[q[hh]]; i != -1; i = ne[i]) { int v = e[i]; if (fa[hh] != -1 \u0026amp;\u0026amp; st[v] \u0026amp;\u0026amp; v != fa[hh] \u0026amp;\u0026amp; find(fa[hh], v)) { a = fa[hh]; b = q[hh]; c = v; if (a \u0026gt; b) swap(a, b); if (b \u0026gt; c) swap(b, c); if (a \u0026gt; b) swap(a, b); flag = true; break; } if (!st[v]) { st[v] = true; q[++ tt] = v; fa[tt] = q[hh]; } } if (flag) break; } printf(\u0026#34;%d %d %d \\n\u0026#34;, a, b, c); return 0; }    UPD:2023-10-21\n ","date":"2022-05-01T21:07:00+08:00","permalink":"https://www.pythoner.work/post/sol002-jisuanke-t3633/","title":"景区三角形"},{"content":"比赛简介  题数：4道 时间：2个小时 总分：400分 难度：和CSP-J2难度相当  开始考试 先来讲题。\nA题签到题忽略……\nB：完美数列 题目链接：完美数列\n暴力解法 直接找最大值砍下去。\n60分解法（实际90分） 使用priority_queue来找最大值，一层一层砍。\n正解 二分答案法，非常简洁！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long LL; const int N = 1e6 + 10; int n, p; LL w, s[N]; int a[N]; bool check(int x) { int idx = upper_bound(a, a + n, x) - a; LL len = n - idx; LL tmp = s[idx] - len * x; return tmp \u0026lt;= w / p; } int main() { freopen(\u0026#34;money.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;money.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p \u0026gt;\u0026gt; w; for (int i = 0; i \u0026lt; n; i ++ ) cin \u0026gt;\u0026gt; a[i]; sort(a, a + n); for (int i = n - 1; i \u0026gt;= 0; i -- ) { s[i] = s[i + 1] + a[i]; } int l = 0, r = 1e9 + 10; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (check(mid)) { r = mid; } else { l = mid + 1; } } cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; endl; return 0; }   C：传递 题目链接：传递\n40分 冒泡排序，边排边计算代价，非常暴力……\n正解 这是带权逆序对问题。\n所以通过归并求逆序对，从$p_2$移到$p_1$需要耗费代价\n$((p_2 + mid)^2 + (p_2 + mid - 1)^2 + \u0026hellip; + (p_2 + p_1)^2) + (2 * w[mid] * w[p_2] + 2 * w[mid - 1] * w[p_2] + \u0026hellip; + 2 * w[p_1] * w[p_2]) + (mid - p_1 + 1) * w[p_2]$\n然后，维护$w[i]$和$w[i] ^ 2$的后缀和就OK了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long LL; const int N = 5e5 + 10, P = 1e9 + 7; int n; int w[N], p[N]; int a[N], b[N]; LL sum1[N], sum2[N]; LL ans; void merge(int l, int r) { int mid = (l + r) \u0026gt;\u0026gt; 1; int p1 = l, p2 = mid + 1; int m = l; sum1[mid + 1] = sum2[mid + 1] = 0; for (int i = mid; i \u0026gt;= l; i -- ) { sum1[i] = (sum1[i + 1] + w[i]) % P; sum2[i] = (sum2[i + 1] + ((LL)w[i] * w[i]) % P) % P; } while (p1 \u0026lt;= mid \u0026amp;\u0026amp; p2 \u0026lt;= r) { if (p[p1] \u0026lt;= p[p2]) { b[m] = w[p1]; a[m ++ ] = p[p1 ++ ]; } else { ans = (ans + sum2[p1]) % P; ans = (ans + 2 * sum1[p1] * w[p2] % P) % P; ans = (ans + (LL)(mid - p1 + 1) * w[p2] * w[p2] % P) % P; b[m] = w[p2]; a[m ++ ] = p[p2 ++ ]; } } while (p1 \u0026lt;= mid) { b[m] = w[p1]; a[m ++ ] = p[p1 ++ ]; } while (p2 \u0026lt;= r) { b[m] = w[p2]; a[m ++ ] = p[p2 ++ ]; } for (int i = l; i \u0026lt;= r; i ++ ) { p[i] = a[i]; w[i] = b[i]; } } void msort(int l, int r) { if (l == r) { return; } int mid = (l + r) \u0026gt;\u0026gt; 1; msort(l, mid); msort(mid + 1, r); merge(l, r); } int main() { freopen(\u0026#34;transfer.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); freopen(\u0026#34;transfer.out\u0026#34;, \u0026#34;w\u0026#34;, stdout); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i ++ ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i]); } for (int i = 1; i \u0026lt;= n; i ++ ) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;p[i]); } msort(1, n); printf(\u0026#34;%lld\u0026#34;, ans); return 0; }   D：景区三角形 题目链接：景区三角形\n暴力解法 就$O(n^3)$找三个点，做个check()，就结束了，不再赘述。\n正解 通过bfs找三角形，一个点设一个$fa$，根（1）等于$-1$。\n有点像找生成树。\n找到一个点$v$，判断$fa$，$cur$，$v$是否构成三角形，如果是，排序放进答案里输出，如果$v$没遍历过，遍历$v$。\n这道题我写了更详细的题解： 题解-景区三角形\n总结 不能放弃，记得调试 C题本来能40分的，但是没调试，放弃了，代码都没存档……\n注意亿些关于输入输出的低级问题 赛后调试一道题时发现有问题，结果，没想到，freopen忘记注释了……\n要用草稿纸 不用草稿纸基本只能做签到题，有些考试中的B题可能也不难，也能做出来。 关于C题的推导其实很长这件事……\n想算法时的方法很重要 签到题如果复杂度不超标就行，这回也就简简单单一个快速幂。\n其他题可以由复杂度推出算法，或是从暴力法开始优化，都可以。\n UPD:2023/10/21\n ","date":"2022-04-23T15:00:00+08:00","permalink":"https://www.pythoner.work/post/sol001-jisuanke-202204/","title":"计蒜客4月月赛（普及组）"},{"content":"功能 1 2 3 4  add(8); add(9); find(10); // false find(8); // true   实现 首先，写一个散列函数。\n1 2 3  int get(int x) { return (x % N + N) % N; // 解决负数问题 }   接着，就出现了问题，散列值可能发生碰撞，如何解决呢？\n拉链法 每个散列值存一个链表（结构就很像邻接表了）。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  #include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 100003; int h[N], e[N], ne[N], idx; void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); memset(h, -1, sizeof h); while (n -- ) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); if (*op == \u0026#39;I\u0026#39;) { insert(x); } else { if (find(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; }   开放寻址法 通过让N增大减少碰撞。 并在每次碰撞发生时向后找空位（这是放的时候）。 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt; using namespace std; const int N = 200003, null = 0x3f3f3f3f; int h[N]; int find(int x) { int t = (x % N + N) % N; while (h[t] != null \u0026amp;\u0026amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } int main() { memset(h, 0x3f, sizeof h); int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); while (n -- ) { char op[2]; int x; scanf(\u0026#34;%s%d\u0026#34;, op, \u0026amp;x); if (*op == \u0026#39;I\u0026#39;) { h[find(x)] = x; } else { if (h[find(x)] == null) puts(\u0026#34;No\u0026#34;); else puts(\u0026#34;Yes\u0026#34;); } } return 0; }   ","date":"2022-04-21T21:24:00+08:00","permalink":"https://www.pythoner.work/post/ds001-hashtable/","title":"哈希表"},{"content":"循环队列 功能 节省空间。\n普通队列用过的空间不能用了，循环队列可以重复利用。\n1  push(1); pop(); push(2); pop();   代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  #include \u0026lt;iostream\u0026gt; using namespace std; // 队列长度，可以自己修改。 const int N = 10; // 队列 struct Queue { int q[N]; int hh = 1, tt = 0; void push(int x) { q[( ++ tt) % N] = x; if (hh / N \u0026amp;\u0026amp; tt / N) { hh -= (int)min(hh / N, tt / N) * N; tt -= (int)min(hh / N, tt / N) * N; } } void pop() { hh ++ ; } int front() { return q[hh % N]; } int back() { return q[tt % N]; } bool empty() { return hh \u0026gt; tt; } int size() { return tt - hh + 1; } }; // 调试 int main() { Queue q; q.push(1); q.pop(); q.push(1); q.push(2); cout \u0026lt;\u0026lt; (q.empty() ? \u0026#39;Y\u0026#39; : \u0026#39;N\u0026#39;) \u0026lt;\u0026lt; endl; q.push(3); q.pop(); q.pop(); q.pop(); q.push(1); q.push(2); q.push(3); cout \u0026lt;\u0026lt; q.front() \u0026lt;\u0026lt; \u0026#39; \u0026#39;; cout \u0026lt;\u0026lt; q.back() \u0026lt;\u0026lt; endl; q.push(4); q.push(5); cout \u0026lt;\u0026lt; q.size(); q.push(6); q.pop(); q.pop(); q.pop(); q.pop(); q.pop(); q.pop(); return 0; }    UPD:2023-10-21\n ","date":"2022-04-19T15:25:00+08:00","permalink":"https://www.pythoner.work/post/algo001-circular-linked-list/","title":"循环队列"}]